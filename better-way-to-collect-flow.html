<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Cách an toàn để thu thập các flow ở Android UI</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/android_blog/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/android_blog/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/android_blog/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Một nơi mà tôi và bạn có thể học Android cùng nhau" />
    <link rel="shortcut icon" href="/android_blog/assets/images/favicon.png" type="image/png" />
    <link rel="canonical" href="/android_blog/better-way-to-collect-flow" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Kendis .dev" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Cách an toàn để thu thập các flow ở Android UI" />
    <meta property="og:description" content="Học cách sử dụng API Lifecycle.repeatOnLifecycle để an toàn thu thập flows ở tầng UI trên Android. Trong một ứng dụng Android, Kotlin flows thường được thu thập từ UI để hiển thị cập nhật dữ liệu trên màn hình. Tuy nhiên, bạn muốn thu thập những flows này, bạn" />
    <meta property="og:url" content="/android_blog/better-way-to-collect-flow" />
    <meta property="og:image" content="/android_blog/assets/images/collect-flow.png" />
    <meta property="article:publisher" content="https://www.facebook.com/kendis1002" />
    <meta property="article:author" content="https://www.facebook.com/kendis1002" />
    <meta property="article:published_time" content="2024-01-22T10:18:00+00:00" />
    <meta property="article:modified_time" content="2024-01-22T10:18:00+00:00" />
    <meta property="article:tag" content="Coroutine" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Cách an toàn để thu thập các flow ở Android UI" />
    <meta name="twitter:description" content="Học cách sử dụng API Lifecycle.repeatOnLifecycle để an toàn thu thập flows ở tầng UI trên Android. Trong một ứng dụng Android, Kotlin flows thường được thu thập từ UI để hiển thị cập nhật dữ liệu trên màn hình. Tuy nhiên, bạn muốn thu thập những flows này, bạn" />
    <meta name="twitter:url" content="/android_blog/" />
    <meta name="twitter:image" content="/android_blog/assets/images/collect-flow.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Kendis .dev" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Coroutine" />
    <meta name="twitter:site" content="@false" />
    <meta name="twitter:creator" content="@false" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Kendis .dev",
        "logo": "/android_blog/false"
    },
    "url": "/android_blog/better-way-to-collect-flow",
    "image": {
        "@type": "ImageObject",
        "url": "/android_blog/assets/images/collect-flow.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/android_blog/better-way-to-collect-flow"
    },
    "description": "Học cách sử dụng API Lifecycle.repeatOnLifecycle để an toàn thu thập flows ở tầng UI trên Android. Trong một ứng dụng Android, Kotlin flows thường được thu thập từ UI để hiển thị cập nhật dữ liệu trên màn hình. Tuy nhiên, bạn muốn thu thập những flows này, bạn"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Cách an toàn để thu thập các flow ở Android UI" href="/android_blog/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="/android_blog/">Kendis .dev</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/android_blog/">Trang chủ</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/android_blog/tag/architecture/">Architecture</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/android_blog/tag/coroutine/">Coroutine</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/android_blog/tag/hilt/">Hilt</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/android_blog/tag/compose/">Compose</a></li>
    <li class="nav-about" role="menuitem"><a href="/android_blog/about/">Tôi</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
                <a class="social-link social-link-fb" href="https://facebook.com/kendis1002" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>
</a>
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Theo dõi</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag-coroutine post ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="22 January 2024">22 January 2024</time>
                </section>
                
                    
                        
                        <span class="post-card-tags">
                            <a href='/android_blog/tag/coroutine/' style="color:white;">COROUTINE</a>
                        </span>
                        
                    
                
                <h1 class="post-full-title">Cách an toàn để thu thập các flow ở Android UI</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/android_blog/assets/images/collect-flow.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <p>Học cách sử dụng API Lifecycle.repeatOnLifecycle để an toàn thu thập flows ở tầng UI trên Android.</p>

<p>Trong một ứng dụng Android, <a href="https://developer.android.com/kotlin/flow">Kotlin flows</a> thường được thu thập từ UI để hiển thị cập nhật dữ liệu trên màn hình. Tuy nhiên, bạn muốn thu thập những flows này, bạn phải đảm bảo rằng bạn không làm việc nhiều hơn cần thiết, lãng phí tài nguyên (cả CPU và bộ nhớ) hoặc rò rỉ dữ liệu khi giao diện đi vào nền.</p>

<p>Trong bài viết này, bạn sẽ tìm hiểu cách <code class="language-plaintext highlighter-rouge">Lifecycle.repeatOnLifecycle</code> và <code class="language-plaintext highlighter-rouge">Flow.flowWithLifecycle</code> bảo vệ bạn khỏi lãng phí tài nguyên và tại sao chúng là một lựa chọn tốt để sử dụng cho việc thu thập flow trong UI.</p>

<h2 id="lãng-phí-tài-nguyên">Lãng phí tài nguyên</h2>
<p>API Flow<T> nên được xuất ra từ các tầng thấp hơn của cấu trúc ứng dụng của bạn bất kể chi tiết cài đặt của item phát flow. Tuy nhiên, bạn cũng nên thu thập chúng một cách an toàn.</T></p>

<p>Một cold flow được hỗ trợ bởi một <a href="https://kotlinlang.org/docs/channels.html">Channel</a> hoặc sử dụng các toán tử với bộ đệm như <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html"><code class="language-plaintext highlighter-rouge">buffer</code></a>, <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html"><code class="language-plaintext highlighter-rouge">conflate</code></a>, <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html"><code class="language-plaintext highlighter-rouge">flowOn</code></a> hoặc <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html"><code class="language-plaintext highlighter-rouge">shareIn</code></a> không an toàn để thu thập với một số API hiện có như <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html"><code class="language-plaintext highlighter-rouge">CoroutineScope.launch</code></a>, [Flow<T>.launchIn](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html) hoặc [```LifecycleCoroutineScope.launchWhenX```](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope), trừ khi bạn hủy ```job``` bắt đầu coroutine khi Activity đi vào nền. Những API này sẽ giữ nguyên flow phát item trong flow vẫn hoạt động trong khi phát ra các item vào bộ đệm ở nền, và do đó lãng phí tài nguyên.</T></p>

<blockquote>
  <p>Ghi chú: Cold flow là một loại folw thực hiện khối phát khi có một người đăng ký mới.</p>
</blockquote>

<p>Ví dụ, hãy xem xét flow này phát ra cập nhật Vị trí bằng cách sử dụng callbackFlow:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Implementation of a cold flow backed by a Channel that sends Location updates</span>
<span class="k">fun</span> <span class="nc">FusedLocationProviderClient</span><span class="p">.</span><span class="nf">locationFlow</span><span class="p">()</span> <span class="p">=</span> <span class="n">callbackFlow</span><span class="p">&lt;</span><span class="nc">Location</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">callback</span> <span class="p">=</span> <span class="kd">object</span> <span class="err">: </span><span class="nc">LocationCallback</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">override</span> <span class="k">fun</span> <span class="nf">onLocationResult</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="nc">LocationResult</span><span class="p">?)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">?:</span> <span class="k">return</span>
            <span class="k">try</span> <span class="p">{</span> <span class="nf">offer</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">lastLocation</span><span class="p">)</span> <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="nc">Exception</span><span class="p">)</span> <span class="p">{}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">requestLocationUpdates</span><span class="p">(</span><span class="nf">createLocationRequest</span><span class="p">(),</span> <span class="n">callback</span><span class="p">,</span> <span class="nc">Looper</span><span class="p">.</span><span class="nf">getMainLooper</span><span class="p">())</span>
        <span class="p">.</span><span class="nf">addOnFailureListener</span> <span class="p">{</span> <span class="n">e</span> <span class="p">-&gt;</span>
            <span class="nf">close</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="c1">// in case of exception, close the Flow</span>
        <span class="p">}</span>
    <span class="c1">// clean up when Flow collection ends</span>
    <span class="nf">awaitClose</span> <span class="p">{</span>
        <span class="nf">removeLocationUpdates</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Lưu ý: Bên trong, callbackFlow sử dụng một Channel, mà khá tương tự với hàng đợi chặn, và có dung lượng mặc định là 64 phần tử.</p>
</blockquote>

<p>Thu thập flow này ở UI bằng cách sử dụng bất kỳ API nào đã đề cập giữ cho flow phát ra các vị trí ngay cả khi giao diện không hiển thị chúng trong UI! Xem ví dụ dưới đây:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LocationActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="nc">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>

        <span class="c1">// Collects from the flow when the View is at least STARTED and</span>
        <span class="c1">// SUSPENDS the collection when the lifecycle is STOPPED.</span>
        <span class="c1">// Collecting the flow cancels when the View is DESTROYED.</span>
        <span class="n">lifecycleScope</span><span class="p">.</span><span class="nf">launchWhenStarted</span> <span class="p">{</span>
            <span class="n">locationProvider</span><span class="p">.</span><span class="nf">locationFlow</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span>
                <span class="c1">// New location! Update the map</span>
            <span class="p">}</span> 
        <span class="p">}</span>
        <span class="c1">// Same issue with:</span>
        <span class="c1">// - lifecycleScope.launch { /* Collect from locationFlow() here */ }</span>
        <span class="c1">// - locationProvider.locationFlow().onEach { /* ... */ }.launchIn(lifecycleScope)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lifecycleScope.launchWhenStarted</code> tạm dừng việc thực hiện coroutine. Các vị trí mới không được xử lý, nhưng nguồn phát của <code class="language-plaintext highlighter-rouge">callbackFlow</code> vẫn tiếp tục gửi các vị trí. Sử dụng <code class="language-plaintext highlighter-rouge">lifecycleScope.launch</code> hoặc <code class="language-plaintext highlighter-rouge">launchIn</code> APIs còn nguy hiểm hơn vì view vẫn tiếp tục tiêu thụ các vị trí ngay cả khi nó ở nền! Điều này có thể gây crash ứng dụng của bạn.</p>

<p>Để giải quyết vấn đề này với các APIs này, bạn cần phải hủy bỏ việc thu thập một cách thủ công khi view đi vào nền để hủy bỏ <code class="language-plaintext highlighter-rouge">callbackFlow</code> và tránh việc location nguồn phát phát ra các item và lãng phí tài nguyên. Ví dụ, bạn có thể làm một cái gì đó như sau:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LocationActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// Coroutine listening for Locations</span>
    <span class="k">private</span> <span class="kd">var</span> <span class="py">locationUpdatesJob</span><span class="p">:</span> <span class="nc">Job</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onStart</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onStart</span><span class="p">()</span>
        <span class="n">locationUpdatesJob</span> <span class="p">=</span> <span class="n">lifecycleScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
            <span class="n">locationProvider</span><span class="p">.</span><span class="nf">locationFlow</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span>
                <span class="c1">// New location! Update the map</span>
            <span class="p">}</span> 
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onStop</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Stop collecting when the View goes to the background</span>
        <span class="n">locationUpdatesJob</span><span class="o">?.</span><span class="nf">cancel</span><span class="p">()</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onStop</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Đó là một giải pháp tốt, nhưng đó là boilerplate. Và nếu có một sự thật vô cùng về các nhà phát triển Android, đó là chúng ta cực kì ghét việc viết code boilerplate. Một trong những lợi ích lớn nhất của việc không cần phải viết code boilerplate là với ít code hơn, có ít cơ hội mắc lỗi hơn!</p>

<h2 id="lifecyclerepeatonlifecycle">Lifecycle.repeatOnLifecycle</h2>

<p>Bây giờ khi chúng ta đều hiểu vấn đề nằm ở đâu, đến lúc nghĩ ra một giải pháp. Giải pháp cần phải 1) đơn giản, 2) thân thiện hoặc dễ nhớ/hiểu, và quan trọng hơn là 3) an toàn! Nó nên hoạt động cho tất cả các trường hợp sử dụng không phụ thuộc vào các chi tiết triển khai flow.</p>

<p>Không cần phải chờ đợi nữa, API mà bạn nên sử dụng là <code class="language-plaintext highlighter-rouge">Lifecycle.repeatOnLifecycle</code> có sẵn trong thư viện <a href="https://developer.android.com/jetpack/androidx/releases/lifecycle">lifecycle-runtime-ktx</a>.</p>

<blockquote>
  <p>Chú ý: API này có sẵn trong thư viện lifecycle:lifecycle-runtime-ktx:2.4.0-alpha01 hoặc mới hơn.</p>
</blockquote>

<p>Nhìn vào đoạn code sau đây:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LocationActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="nc">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>

        <span class="c1">// Create a new coroutine since repeatOnLifecycle is a suspend function</span>
        <span class="n">lifecycleScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
            <span class="c1">// The block passed to repeatOnLifecycle is executed when the lifecycle</span>
            <span class="c1">// is at least STARTED and is cancelled when the lifecycle is STOPPED.</span>
            <span class="c1">// It automatically restarts the block when the lifecycle is STARTED again.</span>
            <span class="n">lifecycle</span><span class="p">.</span><span class="nf">repeatOnLifecycle</span><span class="p">(</span><span class="nc">Lifecycle</span><span class="p">.</span><span class="nc">State</span><span class="p">.</span><span class="nc">STARTED</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Safely collect from locationFlow when the lifecycle is STARTED</span>
                <span class="c1">// and stops collection when the lifecycle is STOPPED</span>
                <span class="n">locationProvider</span><span class="p">.</span><span class="nf">locationFlow</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span>
                    <span class="c1">// New location! Update the map</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">repeatOnLifecycle</code> là một suspend function có tham số là <code class="language-plaintext highlighter-rouge">Lifecycle.State</code> được sử dụng để <strong>tự động tạo và khởi chạy một coroutine mới</strong> với khối code được truyền vào khi vòng đời ở trạng thái nhất định, và hủy coroutine đang diễn ra khi vòng đời rơi xuống dưới trạng thái đó.</p>

<p>Điều này tránh bất kỳ mã boilerplate nào vì mã liên quan để hủy coroutine khi nó không còn cần thiết được thực hiện tự động bởi <code class="language-plaintext highlighter-rouge">repeatOnLifecycle</code>. Như bạn có thể đoán, nó được khuyến nghị để gọi API này trong phương thức <code class="language-plaintext highlighter-rouge">onCreate</code> của activity hoặc <code class="language-plaintext highlighter-rouge">onViewCreated</code> của fragment để tránh hành vi không mong muốn. Xem ví dụ dưới đây sử dụng fragment:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LocationFragment</span><span class="p">:</span> <span class="nc">Fragment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onViewCreated</span><span class="p">(</span><span class="n">view</span><span class="p">:</span> <span class="nc">View</span><span class="p">,</span> <span class="n">savedInstanceState</span><span class="p">:</span> <span class="nc">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">viewLifecycleOwner</span><span class="p">.</span><span class="n">lifecycleScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
            <span class="n">viewLifecycleOwner</span><span class="p">.</span><span class="nf">repeatOnLifecycle</span><span class="p">(</span><span class="nc">Lifecycle</span><span class="p">.</span><span class="nc">State</span><span class="p">.</span><span class="nc">STARTED</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">locationProvider</span><span class="p">.</span><span class="nf">locationFlow</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span>
                    <span class="c1">// New location! Update the map</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Quan trọng</strong>: Fragment luôn nên sử dụng <code class="language-plaintext highlighter-rouge">viewLifecycleOwner</code> để cập nhật giao diện người dùng. Tuy nhiên, điều này không áp dụng cho <code class="language-plaintext highlighter-rouge">DialogFragment</code> vì đôi khi chúng không có một View. Đối với <code class="language-plaintext highlighter-rouge">DialogFragment</code>, bạn có thể sử dụng lifecycleOwner.</p>

<blockquote>
  <p>Chú ý: API này có sẵn trong thư viện lifecycle:lifecycle-runtime-ktx:2.4.0-alpha01 hoặc mới hơn.</p>
</blockquote>

<h2 id="bên-dưới">Bên dưới</h2>

<p>Hàm <code class="language-plaintext highlighter-rouge">repeatOnLifecycle</code> tạm dừng coroutine gọi, khởi động lại khối code khi vòng đời di chuyển vào và ra khỏi <code class="language-plaintext highlighter-rouge">state</code> cụ thể trong một coroutine mới, và t<strong>iếp tục coroutine gọi khi vòng đời bị hủy</strong>. Điểm cuối cùng này rất quan trọng: coroutine gọi <code class="language-plaintext highlighter-rouge">repeatOnLifecycle</code> sẽ không tiếp tục thực hiện cho đến khi vòng đời bị hủy.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LocationActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="nc">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>

        <span class="c1">// Create a coroutine</span>
        <span class="n">lifecycleScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
            
            <span class="n">lifecycle</span><span class="p">.</span><span class="nf">repeatOnLifecycle</span><span class="p">(</span><span class="nc">Lifecycle</span><span class="p">.</span><span class="nc">State</span><span class="p">.</span><span class="nc">RESUMED</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Repeat when the lifecycle is RESUMED, cancel when PAUSED</span>
            <span class="p">}</span>

            <span class="c1">// `lifecycle` is DESTROYED when the coroutine resumes. repeatOnLifecycle</span>
            <span class="c1">// suspends the execution of the coroutine until the lifecycle is DESTROYED.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="sơ-đồ-trực-quan">Sơ đồ trực quan</h2>

<p>Quay lại từ đầu, việc thu thập <code class="language-plaintext highlighter-rouge">locationFlow</code> trực tiếp từ một coroutine bắt đầu bằng <code class="language-plaintext highlighter-rouge">lifecycleScope.launch</code> là rất nguy hiểm vì quá trình thu thập vẫn tiếp tục diễn ra ngay cả khi View đang ở chế độ nền.</p>

<p><code class="language-plaintext highlighter-rouge">repeatOnLifecycle</code> giúp bạn tránh lãng phí tài nguyên và gặp app crash vì nó dừng và khởi động lại bộ sưu tập flow khi vòng đời di chuyển vào và ra khỏi trạng thái mục tiêu.</p>

<p><img src="/Users/trandinhquy/Documents/Blog/jasper2/assets/images/collect-flow-1.png" alt="Sự khác biệt giữa việc sử dụng và không sử dụng API repeatOnLifecycle." title="Sự khác biệt giữa việc sử dụng và không sử dụng API repeatOnLifecycle." /></p>

<h2 id="flowflowwithlifecycle">Flow.flowWithLifecycle</h2>

<p>Bạn cũng có thể sử dụng toán tử <code class="language-plaintext highlighter-rouge">Flow.flowWithLifecycle</code> khi bạn chỉ có một flow để thu thập. API này sử dụng API <code class="language-plaintext highlighter-rouge">Lifecycle.repeatOnLifecycle</code> và phát ra các item và hủy bỏ nguồn phát cơ bản khi <code class="language-plaintext highlighter-rouge">Lifecycle</code> di chuyển vào và ra khỏi trạng thái mục tiêu.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LocationActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="nc">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>

        <span class="n">locationProvider</span><span class="p">.</span><span class="nf">locationFlow</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">flowWithLifecycle</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nc">Lifecycle</span><span class="p">.</span><span class="nc">State</span><span class="p">.</span><span class="nc">STARTED</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">onEach</span> <span class="p">{</span>
                <span class="c1">// New location! Update the map</span>
            <span class="p">}</span>
            <span class="p">.</span><span class="nf">launchIn</span><span class="p">(</span><span class="n">lifecycleScope</span><span class="p">)</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Lưu ý: Tên API này lấy toán tử <code class="language-plaintext highlighter-rouge">Flow.flowOn(CoroutineContext)</code> làm tiền lệ vì <code class="language-plaintext highlighter-rouge">Flow.flowWithLifecycle</code> thay đổi <code class="language-plaintext highlighter-rouge">CoroutineContext</code> được sử dụng để thu thập upstream flow nguồn lên trong khi không ảnh hưởng đến downstream flow. Tương tự như <code class="language-plaintext highlighter-rouge">flowOn</code>, <code class="language-plaintext highlighter-rouge">Flow.flowWithLifecycle</code> cũng thêm một bộ đệm trong trường hợp consumer không theo kịp nguồn phát. Điều này là do việc triển khai nó sử dụng một <code class="language-plaintext highlighter-rouge">callbackFlow</code>.</p>
</blockquote>

<h2 id="định-cấu-hình-nhà-nguồn-phát-cơ-bản">Định cấu hình nhà nguồn phát cơ bản</h2>

<p>Ngay cả khi bạn sử dụng các API này, hãy cẩn thận với các flow nóng có thể lãng phí tài nguyên ngay cả khi chúng không được ai thu thập! Có một số trường hợp sử dụng hợp lệ cho chúng, nhưng hãy ghi nhớ điều đó và ghi lại nếu cần. Việc để nguồn phát flow cơ bản hoạt động ở chế độ nền, ngay cả khi lãng phí tài nguyên, có thể có lợi cho một số trường hợp sử dụng: bạn có ngay dữ liệu mới thay vì bắt kịp và tạm thời hiển thị dữ liệu cũ. <strong>Tùy thuộc vào trường hợp sử dụng, quyết định xem nguồn phát có cần luôn hoạt động hay không</strong>.</p>

<p>Các API <code class="language-plaintext highlighter-rouge">MutableStateFlow</code> và <code class="language-plaintext highlighter-rouge">MutableSharedFlow</code> hiển thị trường <code class="language-plaintext highlighter-rouge">subscriptionCount</code> mà bạn có thể sử dụng để dừng nguồn phát cơ bản khi số lượt đăng ký bằng 0. Theo mặc định, chúng sẽ giữ cho nguồn phát hoạt động miễn là đối tượng chứa instance của flow vẫn còn trong bộ nhớ. Tuy nhiên, có một số trường hợp sử dụng hợp lệ cho việc này, chẳng hạn như <code class="language-plaintext highlighter-rouge">UiState</code> được hiển thị từ ViewModel tới giao diện người dùng bằng <code class="language-plaintext highlighter-rouge">StateFlow</code>. Vậy là được rồi! Trường hợp sử dụng này yêu cầu ViewModel luôn cung cấp trạng thái giao diện người dùng mới nhất cho View.</p>

<p>Tương tự, toán tử<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html"><code class="language-plaintext highlighter-rouge">Flow.stateIn</code></a> và <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html"><code class="language-plaintext highlighter-rouge">Flow.shareIn</code></a> có thể cấu hình với <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/index.html">sharing started policy</a> cho việc này. <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-while-subscribed.html"><code class="language-plaintext highlighter-rouge">WhileSubscribed()</code></a> sẽ dừng nguồn phát cơ bản khi mà không có observer nào! Ngược lại, <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-eagerly.html"><code class="language-plaintext highlighter-rouge">Eagerly</code></a> hay <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-lazily.html"><code class="language-plaintext highlighter-rouge">Lazily</code></a> sẽ giữ nguồn phát cơ bản hoạt động miễn là <code class="language-plaintext highlighter-rouge">CoroutineScope</code> sử dụng vẫn hoạt động.</p>

<blockquote>
  <p>Lưu ý: Các API hiển thị trong bài viết này là một mặc định phù hợp để thu thập các flow từ UI và nên được sử dụng bất kể chi tiết triển khai flow đó như thế nào. Các API này thực hiện những việc cần làm: ngừng thu thập nếu UI không hiển thị trên màn hình. Việc triển khai flow có luôn hoạt động hay không là tùy thuộc vào việc triển khai flow.</p>
</blockquote>

<h2 id="thu-thập-flow-an-toàn-trong-jetpack-compose">Thu thập Flow an toàn trong Jetpack Compose</h2>

<p>Hàm <code class="language-plaintext highlighter-rouge">Flow.collectAsState</code> được dùng trong Compose để thu thập các flow từ các composable và biểu thị các giá trị dưới dạng <code class="language-plaintext highlighter-rouge">State&lt;T&gt;</code> để có thể cập nhật UI Compose. Ngay cả khi Compose không render lại, người dùng khi Activity hoặc Fragment ở chế độ nền thì nguồn phát flow vẫn hoạt động và có thể lãng phí tài nguyên. Compose có thể gặp phải vấn đề tương tự như hệ thống View.</p>

<p>Khi thu thập các flow trong Compose, hãy sử dụng toán tử <code class="language-plaintext highlighter-rouge">Flow.flowWithLifecycle</code> như sau:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">LocationScreen</span><span class="p">(</span><span class="n">locationFlow</span><span class="p">:</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Flow</span><span class="p">&gt;)</span> <span class="p">{</span>

    <span class="kd">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="nc">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
    <span class="kd">val</span> <span class="py">locationFlowLifecycleAware</span> <span class="p">=</span> <span class="nf">remember</span><span class="p">(</span><span class="n">locationFlow</span><span class="p">,</span> <span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">locationFlow</span><span class="p">.</span><span class="nf">flowWithLifecycle</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">,</span> <span class="nc">Lifecycle</span><span class="p">.</span><span class="nc">State</span><span class="p">.</span><span class="nc">STARTED</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">val</span> <span class="py">location</span> <span class="k">by</span> <span class="n">locationFlowLifecycleAware</span><span class="p">.</span><span class="nf">collectAsState</span><span class="p">()</span>

    <span class="c1">// Current location, do something with it</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lưu ý rằng bạn cần <code class="language-plaintext highlighter-rouge">remember</code> flow nhận biết vòng đời với <code class="language-plaintext highlighter-rouge">locationFlow</code> và <code class="language-plaintext highlighter-rouge">lifecycleOwner</code> chính là chìa khóa để luôn sử dụng cùng một flow trừ khi một trong các khóa thay đổi.</p>

<p>Trong Compose, các tác dụng phụ phải được thực hiện trong môi trường được kiểm soát. Để làm được điều đó, hãy sử dụng <code class="language-plaintext highlighter-rouge">LaunchedEffect</code> để tạo một coroutine tuân theo vòng đời của compose. Trong khối của nó, bạn có thể gọi suspend <code class="language-plaintext highlighter-rouge">Lifecycle.repeatOnLifecycle</code> nếu bạn cần nó để khởi chạy lại một khối code khi vòng đời máy chủ ở một <code class="language-plaintext highlighter-rouge">State</code> nhất định.</p>

<h2 id="so-sánh-với-livedata">So sánh với LiveData</h2>

<p>Bạn có thể nhận thấy rằng API này hoạt động tương tự như <code class="language-plaintext highlighter-rouge">LiveData</code> và điều đó đúng! <code class="language-plaintext highlighter-rouge">LiveData</code>nhận thức được Vòng đời và hành vi khởi động lại của nó khiến nó trở nên lý tưởng để quan sát các flow dữ liệu từ giao diện người dùng. Và đó cũng là trường hợp của các API <code class="language-plaintext highlighter-rouge">Lifecycle.repeatOnLifecycle</code> và <code class="language-plaintext highlighter-rouge">Flow.flowWithLifecycle</code>!</p>

<p>Việc thu thập các flow bằng cách sử dụng các API này là sự thay thế đương nhiên cho <code class="language-plaintext highlighter-rouge">LiveData</code> trong các ứng dụng chỉ dành cho Kotlin. Nếu bạn sử dụng các API này để thu thập flow, <code class="language-plaintext highlighter-rouge">LiveData</code> sẽ không mang lại bất kỳ lợi ích nào so với coroutine và flow. Hơn nữa, các flow còn linh hoạt hơn vì chúng có thể được thu thập từ bất kỳ <code class="language-plaintext highlighter-rouge">Dispatcher</code> nào và chúng có thể được cung cấp sức mạnh bởi tất cả <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/">các toán tử của nó</a>. Ngược lại với <code class="language-plaintext highlighter-rouge">LiveData</code>, có sẵn các toán tử hạn chế và các giá trị của chúng luôn được quan sát từ UI thread.</p>

<h2 id="stateflow-hỗ-trợ-data-binding">StateFlow hỗ trợ data binding</h2>

<p>Một lưu ý khác, một trong những lý do khiến bạn có thể sử dụng <code class="language-plaintext highlighter-rouge">LiveData</code> là vì nó được hỗ trợ data binding. Chà, <code class="language-plaintext highlighter-rouge">StateFlow</code> cũng vậy! Để biết thêm thông tin về hỗ trợ <code class="language-plaintext highlighter-rouge">StateFlow</code> trong data binding, hãy xem <a href="https://developer.android.com/topic/libraries/data-binding/observability#stateflow">tài liệu chính thức</a>.</p>

<hr />

<p>Sử dụng API <code class="language-plaintext highlighter-rouge">Lifecycle.repeatOnLifecycle</code> hoặc <code class="language-plaintext highlighter-rouge">Flow.flowWithLifecycle</code> để thu thập các flow từ lớp giao diện người dùng trong Android một cách an toàn.</p>


                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            
                <!-- <section class="subscribe-form">
                    <h3 class="subscribe-form-title">Subscribe to Kendis .dev</h3>
                    <p>Get the latest posts delivered right to your inbox</p>
                    <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

                </section> -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/android_blog/assets/images/ghost.png" alt="kendis" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/android_blog/author/kendis">Kendis</a></h4>
                                
                                    <p>Một thằng lập trình viên Android</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/android_blog/author/kendis">Read More</a>
                        </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
                    <article class="read-next-card"
                        
                            style="background-image: url(/android_blog/assets/images/blog-cover.jpg)"
                        
                    >
                        <header class="read-next-card-header">
                            <small class="read-next-card-header-sitetitle">&mdash; Kendis .dev &mdash;</small>
                            
                                <h3 class="read-next-card-header-title"><a href="/android_blog/tag/coroutine/">Coroutine</a></h3>
                            
                        </header>
                        <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/></svg>
</div>
                        <div class="read-next-card-content">
                            <ul>
                                
                                
                                  
                                
                                  
                                
                                  
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/android_blog/coroutinescope-application-hilt">Tạo 1 ứng dụng CoroutineScope sử dụng Hilt</a></li>
                                        
                                    
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/android_blog/coroutines-cancellation-exceptions">Exception trong coroutine</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/android_blog/3-mistakes-should-avoid-compose">3 lỗi cần phải tránh khi sử dụng Jetpack Compose</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                            </ul>
                        </div>
                        <footer class="read-next-card-footer">
                            <a href="/android_blog/tag/coroutine/">
                                
                                    Xem tất cả 5 post  →
                                
                            </a>
                        </footer>
                    </article>
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/android_blog/custom-compose-view">
                <div class="post-card-image" style="background-image: url(/android_blog/assets/images/collect-flow.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/android_blog/custom-compose-view">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Compose</span>
                            
                        
                    

                    <h2 class="post-card-title">Custom cardview trong Jetpack Compose</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>Học cách custom view trong Jetpack Compose với ví dụ cụ thể là 1 cardview.

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/android_blog/assets/images/ghost.png" alt="Kendis" />
                        
                        <span class="post-card-author">
                            <a href="/android_blog/author/kendis/">Kendis</a>
                        </span>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      7 phút
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/android_blog/coroutinescope-application-hilt">
                <div class="post-card-image" style="background-image: url(/android_blog/assets/images/viewmodelscope.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/android_blog/coroutinescope-application-hilt">
                <header class="post-card-header">
                    
                        
                            
                               <span class="post-card-tags">Coroutine</span>
                            
                        
                            
                                <span class="post-card-tags">Hilt</span>
                            
                        
                    

                    <h2 class="post-card-title">Tạo 1 ứng dụng CoroutineScope sử dụng Hilt</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>Inject một CoroutineScope phạm vi mức Application sử dụng Hilt.

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/android_blog/assets/images/ghost.png" alt="Kendis" />
                        
                        <span class="post-card-author">
                            <a href="/android_blog/author/kendis/">Kendis</a>
                        </span>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      10 phút
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="/android_blog/">
            
                <img src="/android_blog/assets/images/favicon.png" alt="Kendis .dev icon" />
            
            <span>Kendis .dev</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">Cách an toàn để thu thập các flow ở Android UI</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Chia sẻ <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=C%C3%A1ch+an+to%C3%A0n+%C4%91%E1%BB%83+thu+th%E1%BA%ADp+c%C3%A1c+flow+%E1%BB%9F+Android+UI&amp;url=https://kendis1002.github.io/android_blog/better-way-to-collect-flow"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://kendis1002.github.io/android_blog/better-way-to-collect-flow"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="/android_blog/">Kendis .dev</a> &copy; 2025</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/android_blog/">Latest Posts</a>
                    <a href="https://facebook.com/kendis1002" target="_blank" rel="noopener">Facebook</a>
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Subscribe to Kendis .dev</h1>
                <p class="subscribe-overlay-description">Stay up to date! Get all the latest &amp; greatest posts delivered straight to your inbox</p>
                <!-- <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>
 -->
            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/android_blog/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/android_blog/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69281367-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
