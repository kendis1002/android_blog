<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Antipattern - ViewModel event 1 lần</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/android_blog/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/android_blog/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/android_blog/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Một nơi mà tôi và bạn có thể học Android cùng nhau" />
    <link rel="shortcut icon" href="/android_blog/assets/images/favicon.png" type="image/png" />
    <link rel="canonical" href="/android_blog/viewmodel-events-antipatterns" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Kendis .dev" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Antipattern - ViewModel event 1 lần" />
    <meta property="og:description" content="Bạn nên xử lý ngay các event ViewModel bằng cách update UI state ViewModel event là các hành động bắt nguồn từ ViewModel mà UI cần thực hiện. Chẳng hạn như hiển thị thông báo cho người dùng hoặc chuyển hướng đến một màn hình khác khi state ứng dụng" />
    <meta property="og:url" content="/android_blog/viewmodel-events-antipatterns" />
    <meta property="og:image" content="/android_blog/assets/images/viewmodelscope.png" />
    <meta property="article:publisher" content="https://www.facebook.com/kendis1002" />
    <meta property="article:author" content="https://www.facebook.com/kendis1002" />
    <meta property="article:published_time" content="2023-12-08T10:18:00+00:00" />
    <meta property="article:modified_time" content="2023-12-08T10:18:00+00:00" />
    <meta property="article:tag" content="Architecture" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Antipattern - ViewModel event 1 lần" />
    <meta name="twitter:description" content="Bạn nên xử lý ngay các event ViewModel bằng cách update UI state ViewModel event là các hành động bắt nguồn từ ViewModel mà UI cần thực hiện. Chẳng hạn như hiển thị thông báo cho người dùng hoặc chuyển hướng đến một màn hình khác khi state ứng dụng" />
    <meta name="twitter:url" content="/android_blog/" />
    <meta name="twitter:image" content="/android_blog/assets/images/viewmodelscope.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Kendis .dev" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Architecture" />
    <meta name="twitter:site" content="@false" />
    <meta name="twitter:creator" content="@false" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Kendis .dev",
        "logo": "/android_blog/false"
    },
    "url": "/android_blog/viewmodel-events-antipatterns",
    "image": {
        "@type": "ImageObject",
        "url": "/android_blog/assets/images/viewmodelscope.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/android_blog/viewmodel-events-antipatterns"
    },
    "description": "Bạn nên xử lý ngay các event ViewModel bằng cách update UI state ViewModel event là các hành động bắt nguồn từ ViewModel mà UI cần thực hiện. Chẳng hạn như hiển thị thông báo cho người dùng hoặc chuyển hướng đến một màn hình khác khi state ứng dụng"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Antipattern - ViewModel event 1 lần" href="/android_blog/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="/android_blog/">Kendis .dev</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/android_blog/">Trang chủ</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/android_blog/tag/architecture/">Architecture</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/android_blog/tag/coroutine/">Coroutine</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/android_blog/tag/hilt/">Hilt</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/android_blog/tag/compose/">Compose</a></li>
    <li class="nav-about" role="menuitem"><a href="/android_blog/about/">Tôi</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
                <a class="social-link social-link-fb" href="https://facebook.com/kendis1002" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>
</a>
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Theo dõi</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag-architecture post ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime=" 8 December 2023"> 8 December 2023</time>
                </section>
                
                    
                        
                        <span class="post-card-tags">
                            <a href='/android_blog/tag/architecture/' style="color:white;">ARCHITECTURE</a>
                        </span>
                        
                    
                
                <h1 class="post-full-title">Antipattern - ViewModel event 1 lần</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/android_blog/assets/images/viewmodelscope.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <p>Bạn nên xử lý ngay các event ViewModel bằng cách update UI state</p>

<p>ViewModel event là các hành động bắt nguồn từ ViewModel mà UI cần thực hiện. Chẳng hạn như hiển thị thông báo cho người dùng hoặc chuyển hướng đến một màn hình khác khi state ứng dụng thay đổi.</p>

<p>Hướng dẫn của Google về event ViewModel có hai quan điểm chính:</p>
<ul>
  <li>Bất cứ khi nào một event một lần xuất hiện trong ViewModel, ViewModel nên xử lý event đó ngay lập tức, bằng cách tạo ra cập nhật state. ViewModel chỉ nên công khai state ứng dụng. Việc công khai các event chưa được rút gọn thành state từ ViewModel có nghĩa là ViewModel không phải là source of truth cho state được suy ra từ các event đó. <a href="https://developer.android.com/jetpack/compose/architecture#udf">Unidirectional Data Flow</a> (UDF) mô tả những lợi thế của việc chỉ gửi event đến các object tiêu thụ tồn tại lâu hơn đối tượng tạo ra chúng.</li>
  <li>State của ứng dụng nên được công khai thông qua một trình giữ dữ liệu có thể observable.</li>
</ul>

<p align="center"><img src="assets/images/viewmodel-events-antipatterns-1.png" alt="Theo UDF (Unidirectional Data Flow - Luồng Dữ liệu Một Chiều), state chạy xuống từ ViewModel đến UI và event đi lên từ UI đến ViewModel." title="Theo UDF (Unidirectional Data Flow - Luồng Dữ liệu Một Chiều), state chạy xuống từ ViewModel đến UI và event đi lên từ UI đến ViewModel." /></p>

<p>Trong ứng dụng của bạn, bạn có thể đang sử dụng Kotlin Channels hoặc các reactive streams khác như SharedFlow để truyền event từ ViewModel đến UI, hoặc có thể bạn đã thấy mô hình này trong các dự án khác. Tuy nhiên, khi producer (ViewModel) tồn tại lâu hơn consumer (UI - Compose hoặc Views), như trường hợp của các event ViewModel, các API này <strong>KHÔNG ĐẢM BẢO</strong> việc gửi và xử lý các event đó. Điều này có thể dẫn đến lỗi và các vấn đề trong tương lai cho developer, đồng thời mang lại trải nghiệm người dùng không mong muốn cho hầu hết các ứng dụng.</p>

<blockquote>
  <p>Bạn nên xử lý các event ViewModel ngay lập tức, bằng cách cập nhật UI state. Việc cố gắng công khai các event dưới dạng đối tượng bằng cách sử dụng các giải pháp reactive khác như Channel hoặc SharedFlow không đảm bảo việc gửi và xử lý các event đó.</p>
</blockquote>

<h2 id="case-study">Case Study</h2>

<p>Dưới đây là một ví dụ về việc triển khai ViewModel trong flow thanh toán điển hình của một ứng dụng. Trong đoạn code sau, <code class="language-plaintext highlighter-rouge">MakePaymentViewModel</code> trực tiếp yêu cầu UI điều hướng đến màn hình kết quả thanh toán khi kết quả của yêu cầu thanh toán được trả về. Chúng ta sẽ sử dụng ví dụ này để khám phá lý do tại sao việc xử lý các event một lần của ViewModel như thế này lại gây ra các vấn đề và chi phí kỹ thuật cao hơn.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MakePaymentViewModel</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span> <span class="p">:</span> <span class="nc">ViewModel</span><span class="p">()</span> <span class="p">{</span>

    <span class="kd">val</span> <span class="py">uiState</span><span class="p">:</span> <span class="nc">StateFlow</span><span class="p">&lt;</span><span class="nc">MakePaymentUiState</span><span class="p">&gt;</span> <span class="p">=</span> <span class="cm">/* ... */</span>

    <span class="c1">// ⚠️⚠️ DO NOT DO THIS!! ⚠️⚠️</span>
    <span class="c1">// This one-off ViewModel event hasn't been handled nor reduced to state</span>
    <span class="c1">// Boolean represents whether or not the payment was successful</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">_navigateToPaymentResultScreen</span> <span class="p">=</span> <span class="nc">Channel</span><span class="p">&lt;</span><span class="nc">Boolean</span><span class="p">&gt;()</span>

    <span class="c1">// `receiveAsFlow` makes sure only one collector will process each</span>
    <span class="c1">// navigation event to avoid multiple back stack entries</span>
    <span class="kd">val</span> <span class="py">navigateToPaymentResultScreen</span> <span class="p">=</span> <span class="n">_navigateToPaymentResultScreen</span><span class="p">.</span><span class="nf">receiveAsFlow</span><span class="p">()</span>

    <span class="c1">// Protecting makePayment from concurrent callers</span>
    <span class="c1">// If a payment is in progress, don't trigger it again</span>
    <span class="k">private</span> <span class="kd">var</span> <span class="py">makePaymentJob</span><span class="p">:</span> <span class="nc">Job</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>

    <span class="k">fun</span> <span class="nf">makePayment</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">makePaymentJob</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span>
        
        <span class="n">makePaymentJob</span> <span class="p">=</span> <span class="n">viewModelScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="n">_uiState</span><span class="p">.</span><span class="nf">update</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">isLoading</span> <span class="p">=</span> <span class="k">true</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// Show loading spinner</span>
                <span class="kd">val</span> <span class="py">isPaymentSuccessful</span> <span class="p">=</span> <span class="n">paymentsRepository</span><span class="p">.</span><span class="nf">makePayment</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span>
                <span class="n">_navigateToPaymentResultScreen</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">isPaymentSuccessful</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">ioe</span><span class="p">:</span> <span class="nc">IOException</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span> <span class="n">makePaymentJob</span> <span class="p">=</span> <span class="k">null</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>UI sẽ nhận event này và di chuyển theo:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//////////////////////////////////////////////</span>
<span class="c1">// Jetpack Compose code</span>
<span class="c1">//////////////////////////////////////////////</span>

<span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">MakePaymentScreen</span><span class="p">(</span>
    <span class="n">onPaymentMade</span><span class="p">:</span> <span class="p">(</span><span class="nc">Boolean</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Unit</span><span class="p">,</span>
    <span class="n">viewModel</span><span class="p">:</span> <span class="nc">MakePaymentViewModel</span> <span class="p">=</span> <span class="nf">viewModel</span><span class="p">()</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">currentOnPaymentMade</span> <span class="k">by</span> <span class="nf">rememberUpdatedState</span><span class="p">(</span><span class="n">onPaymentMade</span><span class="p">)</span>
    <span class="kd">val</span> <span class="py">lifecycle</span> <span class="p">=</span> <span class="nc">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">lifecycle</span>

    <span class="c1">// Check whenever navigateToPaymentResultScreen emits a new value</span>
    <span class="c1">// to tell the caller composable the payment was made</span>
    <span class="nc">LaunchedEffect</span><span class="p">(</span><span class="n">viewModel</span><span class="p">,</span> <span class="n">lifecycle</span><span class="p">)</span>  <span class="p">{</span>
        <span class="n">lifecycle</span><span class="p">.</span><span class="nf">repeatOnLifecycle</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="nc">STARTED</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">viewModel</span><span class="p">.</span><span class="n">navigateToPaymentResultScreen</span><span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">isPaymentSuccessful</span> <span class="p">-&gt;</span>
                <span class="nf">currentOnPaymentMade</span><span class="p">(</span><span class="n">isPaymentSuccessful</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Rest of the UI for the login screen.</span>
<span class="p">}</span>


<span class="c1">//////////////////////////////////////////////</span>
<span class="c1">// Activity / Views code</span>
<span class="c1">//////////////////////////////////////////////</span>

<span class="kd">class</span> <span class="nc">MakePaymentActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">viewModel</span><span class="p">:</span> <span class="nc">MakePaymentViewModel</span> <span class="k">by</span> <span class="nf">viewModels</span><span class="p">()</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="nc">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="cm">/* ... */</span>
        <span class="n">lifecycleScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">repeatOnLifecycle</span><span class="p">(</span><span class="nc">Lifecycle</span><span class="p">.</span><span class="nc">State</span><span class="p">.</span><span class="nc">STARTED</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">viewModel</span><span class="p">.</span><span class="n">navigateToPaymentResultScreen</span><span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">isPaymentSuccessful</span> <span class="p">-&gt;</span>
                    <span class="kd">val</span> <span class="py">intent</span> <span class="p">=</span> <span class="nc">Intent</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nc">PaymentResultActivity</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
                    <span class="n">intent</span><span class="p">.</span><span class="nf">putExtra</span><span class="p">(</span><span class="s">"PAYMENT_RESULT"</span><span class="p">,</span> <span class="n">isPaymentSuccessful</span><span class="p">)</span>
                    <span class="nf">startActivity</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span>
                    <span class="nf">finish</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Đoạn code thực hiện việc <code class="language-plaintext highlighter-rouge">navigateToPaymentResultScreen</code> trong ví dụ trên đó có một số lỗi thiết kế.</p>

<h2 id="antipattern-1-trạng-thái-về-việc-hoàn-tất-thanh-toán-có-thể-bị-mất">Antipattern #1: Trạng thái về việc hoàn tất thanh toán có thể bị mất</h2>

<p>Một Channel không đảm bảo việc phân phối và xử lý các event. Do đó, <strong>các event có thể bị mất, dẫn đến UI ở trạng thái không nhất quán</strong>. Ví dụ về điều này có thể xảy ra khi UI (người tiêu thụ) chuyển sang chế độ nền và dừng việc thu thập <code class="language-plaintext highlighter-rouge">Channel</code> ngay sau khi <code class="language-plaintext highlighter-rouge">ViewModel</code> (producer) gửi một event. Điều tương tự cũng có thể xảy ra với các API khác không phải là một loại trình giữ dữ liệu observable, chẳng hạn như <code class="language-plaintext highlighter-rouge">SharedFlow</code>, có thể phát ra các event ngay cả khi không có consumer nào lắng nghe chúng.</p>

<p>Đây là một antipattern vì trạng thái kết quả thanh toán được mô hình hóa trong lớp UI <strong>không bền vững</strong> hoặc <strong>không nguyên tử</strong> nếu chúng ta nghĩ về nó theo thuật ngữ của một giao dịch <strong>ACID</strong>. Việc thanh toán có thể đã thành công theo như repository được biết, nhưng chúng ta chưa bao giờ được chuyển sang màn hình phù hợp tiếp theo.</p>

<p>Lưu ý: Antipattern này có thể được giảm thiểu bằng cách sử dụng Dispatchers.Main.immediate khi gửi và nhận các event. Tuy nhiên, nếu điều đó không được thực thi bởi lint, giải pháp này có thể dễ xảy ra lỗi vì các developer có thể dễ dàng quên nó.</p>

<h2 id="antipattern-2-bắt-ui-hành-động">Antipattern #2: Bắt UI hành động</h2>

<p>Đối với ứng dụng hỗ trợ nhiều kích thước màn hình, hành động UI cần thực hiện khi xảy ra ViewModel event có thể khác nhau tùy thuộc vào kích thước màn hình. Ví dụ: ứng dụng case study nên điều hướng đến màn hình kết quả thanh toán khi chạy trên điện thoại di động; nhưng nếu ứng dụng đang chạy trên máy tính bảng, hành động có thể hiển thị kết quả trong một phần khác của cùng một màn hình.</p>

<p><strong>ViewModel nên cho UI biết state ứng dụng là gì và UI nên xác định cách xử lý đối với state điều đó</strong>. ViewModel không nên cho UI biết hành động nào cần thực hiện.</p>

<h2 id="antipattern-3-không-xử-lý-event-1-lần-ngay-lập-tức">Antipattern #3: Không xử lý event 1 lần ngay lập tức</h2>

<p>Tạo event theo kiểu bắn ra và quên là thứ sẽ tạo ra vấn đề. Nó sẽ rất khó để tuân thử theo các tính chất ACID, cho nên việc đảm bảo độ tin cậy và toàn vẹn dữ liệu không được chắc chắn. State là event đã xảy ra. Sự kiện không được xử lý càng lâu thì vấn đề càng khó sẽ xảy ra.</p>

<p>Trong case study ở trên, chúng ta đã tạo 1 object cho event - đại diện là kiểu Boolean - công khai nó bằng Channel.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create Channel with the event modeled as a Boolean</span>
<span class="kd">val</span> <span class="py">_navigateToPaymentResultScreen</span> <span class="p">=</span> <span class="nc">Channel</span><span class="p">&lt;</span><span class="nc">Boolean</span><span class="p">&gt;()</span>

<span class="c1">// Trigger event</span>
<span class="n">_navigateToPaymentResultScreen</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">isPaymentSuccessful</span><span class="p">)</span>
</code></pre></div></div>

<p>Một khi làm điều này thì bạn phải chịu trách nhiệm đảm bảo rằng mọi thứ chắc chắn khi truyền và xử lý một lần. Nếu bạn phải xây dựng 1 event là một object vì một vài lý do, hãy giới hạn thời gian sống để nó càng ngắn càng tốt thì nó sẽ không có cơ hội bị thất lạc.</p>

<p><strong>Xử lý event 1 lần trong ViewModel thường được thực hiện bằng cách gọi method</strong> - Ví dụ, cập nhật UI. Một khi ban gọi method đó, bạn biết khi nào nó hoàn thành thành công hoặc bắn ra 1 exception, và bạn biết rằng nó sẽ xảy ra chính xác 1 lần.</p>

<h2 id="cải-thiện-case-study">Cải thiện Case Study</h2>

<p>Nếu bạn bị mắc phải 1 trong những trường hợp trên. Hãy xem xét lại rằng event 1 lần trong ViewModel có thực sự có ý nghĩa cho UI của bạn không. Xử lý chúng ngay lập tức và giảm thiểu chúng bằng UI state được công khai bằng observale data hodler như là <code class="language-plaintext highlighter-rouge">StateFlow</code> hoặc <code class="language-plaintext highlighter-rouge">mutableStateOf</code>.</p>

<p><strong>UI state nên diễn tả cho UI tại thời điểm được cho, nó tạo ra một sự đảm bảo tốt hơn trong quá trình truyền và xử lý, nó thường dễ hơn để test, và còn tích hợp một cách nhất quán với phần còn lại của app.</strong></p>

<blockquote>
  <p>Nếu mà bạn còn gặp khó khắn trong việc tìm cách giảm thiểu event 1 lần trong ViewModel để thành state, hãy xem xét lại event đó có thực sự có tác dụng với UI của bạn hay không.</p>
</blockquote>

<p>Trong ví dụ phía trên, ViewModel nên xuất data thực sự của app - thông tin thanh toán đối với trường hợp này - thay vì đưa action cho UI để nó xử lý. Cách phía dưới là phương án tốt hơn về cách mà event trong ViewModel được xử lý, chuyển thành state, và công khai bằng cách dùng observable data holder.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">data class</span> <span class="nc">MakePaymentUiState</span><span class="p">(</span>
    <span class="kd">val</span> <span class="py">paymentInformation</span><span class="p">:</span> <span class="nc">PaymentModel</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">isLoading</span><span class="p">:</span> <span class="nc">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
    <span class="c1">// PaymentResult models the application state of this particular payment attempt,</span>
    <span class="c1">// `null` represents the payment hasn't been made yet.</span>
    <span class="kd">val</span> <span class="py">paymentResult</span><span class="p">:</span> <span class="nc">PaymentResult</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
<span class="p">)</span>

<span class="kd">class</span> <span class="nc">MakePaymentViewModel</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span> <span class="p">:</span> <span class="nc">ViewModel</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">private</span> <span class="kd">val</span> <span class="py">_uiState</span> <span class="p">=</span> <span class="nc">MutableStateFlow</span><span class="p">&lt;</span><span class="nc">MakePaymentUiState</span><span class="p">&gt;(</span><span class="o">..</span><span class="p">.)</span>
    <span class="kd">val</span> <span class="py">uiState</span><span class="p">:</span> <span class="nc">StateFlow</span><span class="p">&lt;</span><span class="nc">MakePaymentUiState</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">_uiState</span><span class="p">.</span><span class="nf">asStateFlow</span><span class="p">()</span>

    <span class="c1">// Protecting makePayment from concurrent callers</span>
    <span class="c1">// If a payment is in progress, don't trigger it again</span>
    <span class="k">private</span> <span class="kd">var</span> <span class="py">makePaymentJob</span><span class="p">:</span> <span class="nc">Job</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>

    <span class="k">fun</span> <span class="nf">makePayment</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">makePaymentJob</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span>

        <span class="n">makePaymentJob</span> <span class="p">=</span> <span class="n">viewModelScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="n">_uiState</span><span class="p">.</span><span class="nf">update</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">isLoading</span> <span class="p">=</span> <span class="k">true</span><span class="p">)</span> <span class="p">}</span>
                <span class="kd">val</span> <span class="py">isPaymentSuccessful</span> <span class="p">=</span> <span class="n">paymentsRepository</span><span class="p">.</span><span class="nf">makePayment</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span>

                <span class="c1">// The event of what to do when the payment response comes back</span>
                <span class="c1">// is immediately handled here. It causes a UI state update.</span>
                <span class="n">_uiState</span><span class="p">.</span><span class="nf">update</span> <span class="p">{</span>
                    <span class="n">it</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span>
                        <span class="n">isLoading</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
                        <span class="n">paymentResult</span> <span class="p">=</span> <span class="nc">PaymentResult</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">paymentInfo</span><span class="p">,</span> <span class="n">isPaymentSuccessful</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">ioe</span><span class="p">:</span> <span class="nc">IOException</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span> <span class="n">makePaymentJob</span> <span class="p">=</span> <span class="k">null</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Trong đoạn code phía trên, event được xử lý ngay lập tức bằng cách gọi <code class="language-plaintext highlighter-rouge">_uiState.update</code> với <code class="language-plaintext highlighter-rouge">paymentResult</code> data. Không có cách gì mà event có thể bị mất. Event đã được chuyển thành state,và field <code class="language-plaintext highlighter-rouge">paymentResult</code> trong <code class="language-plaintext highlighter-rouge">MakePaymentUiState</code> phản ánh data kết quả thanh toán.</p>

<p>Với điều này, Ui sẽ phản ứng với sự thay đổi kết quả thanh toán theo nó như sau:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//////////////////////////////////////////////</span>
<span class="c1">// Jetpack Compose code</span>
<span class="c1">//////////////////////////////////////////////</span>

<span class="nd">@Composable</span>
<span class="k">fun</span> <span class="nf">MakePaymentScreen</span><span class="p">(</span>
    <span class="n">onPaymentMade</span><span class="p">:</span> <span class="p">(</span><span class="nc">PaymentModel</span><span class="p">,</span> <span class="nc">Boolean</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Unit</span><span class="p">,</span>
    <span class="n">viewModel</span><span class="p">:</span> <span class="nc">MakePaymentViewModel</span> <span class="p">=</span> <span class="nf">viewModel</span><span class="p">()</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">uiState</span> <span class="k">by</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">uiState</span><span class="p">.</span><span class="nf">collectAsState</span><span class="p">()</span>

    <span class="n">uiState</span><span class="p">.</span><span class="n">paymentResult</span><span class="o">?.</span><span class="nf">let</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">currentOnPaymentMade</span> <span class="k">by</span> <span class="nf">rememberUpdatedState</span><span class="p">(</span><span class="n">onPaymentMade</span><span class="p">)</span>
        <span class="nc">LaunchedEffect</span><span class="p">(</span><span class="n">uiState</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Tell the caller composable that the payment was made.</span>
            <span class="c1">// the parent composable will act accordingly.</span>
            <span class="nf">currentOnPaymentMade</span><span class="p">(</span>
                <span class="n">uiState</span><span class="p">.</span><span class="n">paymentResult</span><span class="p">.</span><span class="n">paymentModel</span><span class="p">,</span> 
                <span class="n">uiState</span><span class="p">.</span><span class="n">paymentResult</span><span class="p">.</span><span class="n">isPaymentSuccessful</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Rest of the UI for the login screen.</span>
<span class="p">}</span>


<span class="c1">//////////////////////////////////////////////</span>
<span class="c1">// Activity / Views code</span>
<span class="c1">//////////////////////////////////////////////</span>

<span class="kd">class</span> <span class="nc">MakePaymentActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">viewModel</span><span class="p">:</span> <span class="nc">MakePaymentViewModel</span> <span class="k">by</span> <span class="nf">viewModels</span><span class="p">()</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="nc">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="cm">/* ... */</span>
        <span class="n">lifecycleScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">repeatOnLifecycle</span><span class="p">(</span><span class="nc">Lifecycle</span><span class="p">.</span><span class="nc">State</span><span class="p">.</span><span class="nc">STARTED</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">viewModel</span><span class="p">.</span><span class="n">uiState</span><span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">uiState</span> <span class="p">-&gt;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">paymentResult</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kd">val</span> <span class="py">intent</span> <span class="p">=</span> <span class="nc">Intent</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nc">PaymentResultActivity</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
                        <span class="n">intent</span><span class="p">.</span><span class="nf">putExtra</span><span class="p">(</span>
                            <span class="s">"PAYMENT_RESULT"</span><span class="p">,</span> 
                            <span class="n">uiState</span><span class="p">.</span><span class="n">paymentResult</span><span class="p">.</span><span class="n">isPaymentSuccessful</span>
                        <span class="p">)</span>
                        <span class="nf">startActivity</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span>
                        <span class="nf">finish</span><span class="p">()</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Chú ý:</strong> Nếu trong trương hợp mà Activity không <code class="language-plaintext highlighter-rouge">finish()</code> và được giữ trong backstack, ViewModel sẽ cần phải đưa ra 1 function để clear <code class="language-plaintext highlighter-rouge">paymentResult</code> trong UiState(ví dụ: đưa field đó về null) nó sẽ được gọi sau khi Activity gọi Activity mới. Ví dụ về cái này có thể tìm ở đây, trong phần <a href="https://developer.android.com/topic/architecture/ui-layer#additional-considerations">Consuming events can trigger state updates</a> của tài liệu.</p>

<p>Như đã đề cập ở <a href="https://developer.android.com/topic/architecture/ui-layer#additional-considerations">Consuming events can trigger state updates</a>, bạn có thể xuất UI state với màn hình của bạn với nhiều stream nếu điều đó là cần thiết. Điều quan trọng là các stream là observable data holder. Trong ví dụ trên, stream UI state duy nhất được hiển thị do cờ <code class="language-plaintext highlighter-rouge">isLoading</code> và thuộc tính <code class="language-plaintext highlighter-rouge">PaymentResult</code> có mối liên hệ chặt chẽ với nhau. Việc tách chúng ra có thể gây ra sự không nhất quán trong giao diện người dùng — ví dụ: nếu <code class="language-plaintext highlighter-rouge">isLoading</code> là <code class="language-plaintext highlighter-rouge">true</code> và <code class="language-plaintext highlighter-rouge">PaymentResult</code> không rỗng. Bằng cách kết hợp chúng trong cùng một class UiState, chúng ta nhận thức rõ hơn về các field khác nhau tạo nên UI state của màn hình, giúp chúng ta gặp ít lỗi hơn.</p>

<hr />

<p>Hy vọng rằng bài đăng trên blog này đã giúp bạn hiểu lý do tại sao tôi khuyên bạn nên <strong>1) xử lý ngay các sự kiện ViewModel một lần và chuyển thành state</strong> và <strong>2) hiển thị trạng thái bằng cách sử dụng observable data holder</strong>. Tôi tin rằng phương pháp này mang lại cho bạn sự đảm bảo về việc truyền và xử lý hơn, phương pháp này thường dễ để test hơn và tích hợp nhất quán với phần còn lại của ứng dụng.</p>

<p>Để biết thêm thông tin về chủ đề này, hãy xem tài liệu về <a href="https://developer.android.com/topic/architecture/ui-layer/events">UI event documentation</a>.</p>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            
                <!-- <section class="subscribe-form">
                    <h3 class="subscribe-form-title">Subscribe to Kendis .dev</h3>
                    <p>Get the latest posts delivered right to your inbox</p>
                    <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

                </section> -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/android_blog/assets/images/ghost.png" alt="kendis" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/android_blog/author/kendis">Kendis</a></h4>
                                
                                    <p>Một thằng lập trình viên Android</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/android_blog/author/kendis">Read More</a>
                        </div>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/android_blog/best-practices-for-coroutines-in-android">
                <div class="post-card-image" style="background-image: url(/android_blog/assets/images/viewmodelscope.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/android_blog/best-practices-for-coroutines-in-android">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Coroutine</span>
                            
                        
                    

                    <h2 class="post-card-title">Best practices về coroutine trong Android</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>Dưới đây sẽ là một số best practices có tác động tích cực bằng cách làm cho ứng dụng của bạn trở nên có khả năng mở rộng và test tốt hơn khi</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/android_blog/assets/images/ghost.png" alt="Kendis" />
                        
                        <span class="post-card-author">
                            <a href="/android_blog/author/kendis/">Kendis</a>
                        </span>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      10 phút
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/android_blog/viewmodelscope">
                <div class="post-card-image" style="background-image: url(/android_blog/assets/images/viewmodelscope.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/android_blog/viewmodelscope">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Coroutine</span>
                            
                        
                    

                    <h2 class="post-card-title">Coroutines đơn giản trong Android - viewModelScope</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>Tìm hiểu mọi thứ bạn nên biết về viewModelScope

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/android_blog/assets/images/ghost.png" alt="Kendis" />
                        
                        <span class="post-card-author">
                            <a href="/android_blog/author/kendis/">Kendis</a>
                        </span>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      8 phút
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="/android_blog/">
            
                <img src="/android_blog/assets/images/favicon.png" alt="Kendis .dev icon" />
            
            <span>Kendis .dev</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">Antipattern - ViewModel event 1 lần</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Chia sẻ <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=Antipattern+-+ViewModel+event+1+l%E1%BA%A7n&amp;url=https://kendis1002.github.io/android_blog/viewmodel-events-antipatterns"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://kendis1002.github.io/android_blog/viewmodel-events-antipatterns"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="/android_blog/">Kendis .dev</a> &copy; 2025</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/android_blog/">Latest Posts</a>
                    <a href="https://facebook.com/kendis1002" target="_blank" rel="noopener">Facebook</a>
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Subscribe to Kendis .dev</h1>
                <p class="subscribe-overlay-description">Stay up to date! Get all the latest &amp; greatest posts delivered straight to your inbox</p>
                <!-- <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>
 -->
            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/android_blog/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/android_blog/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69281367-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
